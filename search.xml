<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Go爬虫 http code 521问题解决</title>
    <url>/2020/03/29/goquery521/</url>
    <content><![CDATA[<p>今天在帮朋友爬取好大夫网站（<i style="color:#ccc">只是获取某地区的简单数据，非商用</i>）的时候，一直被卡在获取医生个人页面上。打印错误信息发现返回的Http Status Code是521，但是直接打开网页又是正常的。对于这个状态码我并不熟悉，但是前功尽弃又实在不甘心，只好Google寻找答案。</p>
<a id="more"></a>

<p>最终是这篇文章帮到了我：<a href="https://blog.csdn.net/wangdepei/article/details/84798601" target="_blank" rel="noopener"><span class="label info">HTTP STATUS CODE: 521的解决办法</span></a></p>
<p>我在postman和Chrome浏览器上还原这个场景，果然和文章描述非常一致。</p>
<p><a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="noopener"><span class="label info">List of HTTP status codes</span></a> 中对http code 521的定义是：</p>
<blockquote>
<p>Web Server Is Down: The origin server has refused the connection from Cloudflare. </p>
</blockquote>
<p>实际上，这是网站防爬虫的一种措施。了解了这一措施的执行方式，也就可以抽丝剥茧一步一步去解决这个问题了。</p>
<p>具体的分析过程就不赘述了，直接参考上面那篇文章即可，这里我简单记录一下在代码中解决的完成过程：</p>
<ol>
<li><p>发起一个请求，这是正常操作，但是这一次请求肯定不能得到有效的页面，不过都是必走的过程，无法避免。</p>
<p> (1) 先清除cookie（在postman下使用带cookie的请求得到的js代码无法解析，而浏览器是可以正常跳转的，这里不深究了，直接清掉以绝后患）;</p>
<pre><code>设置该请求连接为keep-alive（{% label danger@第二个请求要使用同一个req发起，所以这个请求是不能close的%}）</code></pre> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">req.Header.Del(<span class="string">"Cookie"</span>)</span><br><span class="line">req.Header.Add(<span class="string">"Connection"</span>, <span class="string">"keep-alive"</span>)</span><br><span class="line">req.Close = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p> (2) 发起请求（略）</p>
</li>
<li><p>获取响应头的Set-Cookie属性，打印出来该值如下：</p>
<blockquote>
<span class="label danger"> __jsluid_h=988846693f681c7e063343acefc11072</span>; max-age=31536000; path=/; HttpOnly
</blockquote>
<p> 这里只需要拿到__jsluid_h的值就可以了</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">firstCookie := res.Header.Get(<span class="string">"Set-Cookie"</span>)</span><br><span class="line">firstCookie = strings.Split(sc, <span class="string">";"</span>)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取response body，看起来像是一段js代码和一堆乱码组成，我们只需要<span class="label info">script标签之间的代码</span>，打印输出如下：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="string">"@var@rOm9XFMtA3QKV7nYsPGT4lifyWwkq5vcjH2IdxUoCbhERLaz81DNB6@while@parseInt@@29@@captcha@@replace@Expires@@1585492297@@split@37@RegExp@31@D@@f@length@0@firstChild@@catch@pathname@substr@36@window@cookie@@e@match@@__jsl_clearance@DOMContentLoaded@3@href@@else@0xEDB88320@String@charAt@addEventListener@https@new@false@g@Sun@2BU@challenge@toString@GMT@attachEvent@JgSe0upZ@@C@O@@@@search@location@0xFF@reverse@@@charCodeAt@@Mar@@@dt@Array@join@@try@@6@@eval@@K@chars@createElement@1@toLowerCase@return@@@iz7@@fromCharCode@1500@document@2@8@onreadystatechange@@if@@for@@20@@a@@@IDW@div@@69@setTimeout@Path@@function@15@@r@innerHTML@d@@@@@"</span>.replace(<span class="regexp">/@*$/</span>,<span class="string">""</span>).split(<span class="string">"@"</span>),y=<span class="string">"2 2s=2m()&#123;2j('1h.E=1h.s+1h.1g.b(/[\\?|&amp;]9-15/,\\'\\')',20);21.w='B=e.2i|o|'+(2m()&#123;2 1H=[2m(2s)&#123;1G 2s&#125;,2m(1H)&#123;1G 1H&#125;,(2m()&#123;2 2s=21.1D('2g');2s.2q='&lt;2c E=\\'/\\'&gt;1w&lt;/2c&gt;';2s=2s.p.E;2 1H=2s.z(/L?:\\/\\//)[o];2s=2s.t(1H.n).1F();1G 2m(1H)&#123;28(2 1w=o;1w&lt;1H.n;1w++)&#123;1H[1w]=2s.J(1H[1w])&#125;;1G 1H.1t('')&#125;&#125;)(),2m(2s)&#123;1G 1z('I.1L('+2s+')')&#125;],1w=['1b',[[-~![]]+[-~![]]+(23+[]+[]),(23+[]+[])+(-~(+!![][&#123;&#125;])-~[-~![]-~![]]+[])],'1B',[(-~[-~![]-~![]]+[]+[])+[(-~[]+[-~-~[]]&gt;&gt;-~-~[])-~(+!![][&#123;&#125;])-~[-~![]-~![]]]],'22',[[1x]+[1x]],'2f',(&#123;&#125;+[]+[[]][o]).J((-~![]-~![])*[(-~![]-~![]&lt;&lt;-~![])]),'1c',[[(-~[]+[-~-~[]]&gt;&gt;-~-~[])-~(+!![][&#123;&#125;])-~[-~![]-~![]]]],[[(-~[]+[-~-~[]]&gt;&gt;-~-~[])-~(+!![][&#123;&#125;])-~[-~![]-~![]]]+[-~-~[]]],(!![][&#123;&#125;]+[]).J(D)+(-~(+!![][&#123;&#125;])-~[-~![]-~![]]+[]),[[1x]+(23+[]+[])],'1r',[[-~![]]+[-~![]]+(-~[-~![]-~![]]+[]+[]),[-~![]]+[-~-~[]]+[(+[])]],'2p',[(-~[-~![]-~![]]+[]+[])],[[1x]+(23+[]+[])],'1J',[(-~[-~![]-~![]]+[]+[])+[(-~[]+[-~-~[]]&gt;&gt;-~-~[])-~(+!![][&#123;&#125;])-~[-~![]-~![]]]],'14%',(-~[-~![]-~![]]+[]+[]),'k'];28(2 2s=o;2s&lt;1w.n;2s++)&#123;1w[2s]=1H[[1E,D,1E,D,1E,D,1E,o,1E,22,D,o,D,1E,D,1E,22,D,1E,D,1E,o,1E][2s]](1w[2s])&#125;;1G 1w.1t('')&#125;)()+';c=13, 7-1o-2a 2n:j:h 17;2k=/;'&#125;;26((2m()&#123;1v&#123;1G !!v.K;&#125;r(y)&#123;1G 11;&#125;&#125;)())&#123;21.K('C',2s,11)&#125;G&#123;21.18('24',2s)&#125;"</span>,f=<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">var</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>;x=x.split(<span class="string">""</span>);y=y||<span class="number">99</span>;<span class="keyword">while</span>((a=x.shift())&amp;&amp;(b=a.charCodeAt(<span class="number">0</span>)<span class="number">-77.5</span>))c=(<span class="built_in">Math</span>.abs(b)&lt;<span class="number">13</span>?(b+<span class="number">48.5</span>):<span class="built_in">parseInt</span>(a,<span class="number">36</span>))+y*c;<span class="keyword">return</span> c&#125;,z=f(y.match(<span class="regexp">/\w/g</span>).sort(<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> f(x)-f(y)&#125;).pop());<span class="keyword">while</span>(z++)<span class="keyword">try</span>&#123;<span class="built_in">eval</span>(y.replace(<span class="regexp">/\b\w+\b/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;<span class="keyword">return</span> x[f(y,z)<span class="number">-1</span>]||(<span class="string">"_"</span>+y)&#125;));<span class="keyword">break</span>&#125;<span class="keyword">catch</span>(_)&#123;&#125;&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来要执行上面这段js代码，这里需要用到运行js代码的go包：<a href="https://github.com/robertkrimen/otto" target="_blank" rel="noopener"><span class="label info">github.com/robertkrimen/otto</span></a>，使用方法也很简单，直接参考文档就好。但是上面这段代码还是存在一些问题，直接运行是拿不到任何返回结果的。我的解决方式如下，先使用<span class="label info">console.log()</span>输出控制台日志，再在js代码里加一段代码，返回最后一条log结果。代码如下：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先把上段js代码中的eval替换成console.log</span></span><br><span class="line">js = strings.Replace(js, <span class="string">"eval("</span>, <span class="string">" console.log("</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">// 加入一段返回log的js代码</span></span><br><span class="line">consoleJs := <span class="string">"var lastLog = \"\";console.oldLog = console.log;console.log = function(str) &#123;console.oldLog(str);lastLog = str;&#125;;"</span></span><br><span class="line"><span class="comment">// 拼接起来，并执行最终这段js</span></span><br><span class="line">js = consoleJs + js</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后得到的第二段js代码如下，结果依然非常乱，其他的不用管，直接找到我们需要的第二个cookie的key，也就是<span class="label danger">__jsl_clearance</span>，查看=后面的内容，1585492297.69|0| + function(){}，前半段很好说，主要是后半段的function返回的内容看起来十分隐晦，不过既然是js代码，应该还是可以通过前面的方法获取到的。<br> <i style="font-size:12px;text-align:left;"> <div class="note default">
            <p>var _2s=function(){setTimeout(‘location.href=location.pathname+location.search.replace(/[?|&amp;]captcha-challenge/,&#39;&#39;)’,1500);==document.cookie=’__jsl_clearance===1585492297.69|0|’+(function(){var _1H=[function(_2s){return _2s},function(_1H){return _1H},(function(){var _2s=document.createElement(‘div’);_2s.innerHTML=’&lt;a href=&#39;/&#39;&gt;_1w</a>‘;_2s=_2s.firstChild.href;var _1H=_2s.match(/https?:///)[0];_2s=_2s.substr(_1H.length).toLowerCase();return function(_1H){for(var _1w=0;_1w&lt;_1H.length;_1w++){_1H[_1w]=_2s.charAt(_1H[_1w])};return _1H.join(‘’)}})(),function(_2s){return eval(‘String.fromCharCode(‘+_2s+’)’)}],_1w=[‘C’,[[-<del>![]]+[-</del>![]]+(8+[]+[]),(8+[]+[])+(-<del>(+!![][{}])-</del>[-<del>![]-</del>![]]+[])],’K’,[(-<del>[-</del>![]-<del>![]]+[]+[])+[(-</del>[]+[-<del>-</del>[]]&gt;&gt;-<del>-</del>[])-<del>(+!![][{}])-</del>[-<del>![]-</del>![]]]],’2’,[[6]+[6]],’IDW’,({}+[]+[[]][0]).charAt((-<del>![]-</del>![])*[(-<del>![]-</del>![]&lt;&lt;-<del>![])]),’O’,[[(-</del>[]+[-<del>-</del>[]]&gt;&gt;-<del>-</del>[])-<del>(+!![][{}])-</del>[-<del>![]-</del>![]]]],[[(-<del>[]+[-</del>-<del>[]]&gt;&gt;-</del>-<del>[])-</del>(+!![][{}])-<del>[-</del>![]-<del>![]]]+[-</del>-<del>[]]],(!![][{}]+[]).charAt(3)+(-</del>(+!![][{}])-<del>[-</del>![]-<del>![]]+[]),[[6]+(8+[]+[])],’dt’,[[-</del>![]]+[-<del>![]]+(-</del>[-<del>![]-</del>![]]+[]+[]),[-<del>![]]+[-</del>-<del>[]]+[(+[])]],’r’,[(-</del>[-<del>![]-</del>![]]+[]+[])],[[6]+(8+[]+[])],’iz7’,[(-<del>[-</del>![]-<del>![]]+[]+[])+[(-</del>[]+[-<del>-</del>[]]&gt;&gt;-<del>-</del>[])-<del>(+!![][{}])-</del>[-<del>![]-</del>![]]]],’2BU%’,(-<del>[-</del>![]-~![]]+[]+[]),’D’];for(var _2s=0;_2s&lt;_1w.length;_2s++){_1w[_2s]=_1H<a href="_1w[_2s]">[1,3,1,3,1,3,1,0,1,2,3,0,3,1,3,1,2,3,1,3,1,0,1][_2s]</a>};return _1w.join(‘’)})()+’;Expires=Sun, 29-Mar-20 15:31:37 GMT;Path=/;’};if((function(){try{return !!window.addEventListener;}catch(e){return false;}})()){document.addEventListener(‘DOMContentLoaded’,_2s,false)}else{document.attachEvent(‘onreadystatechange’,_2s)} </p>
          </div> </i> </p>
<p> 以下就是截取出来的cookie值后半段的js代码了（因为在原代码段中这是个闭包函数，截取出来是无法直接执行的，所以只把function中的内容拿出来，并定义为一个新函数f。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> _1H=[<span class="function"><span class="keyword">function</span>(<span class="params">_2s</span>)</span>&#123;<span class="keyword">return</span> _2s&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">_1H</span>)</span>&#123;<span class="keyword">return</span> _1H&#125;,(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> _2s=<span class="built_in">document</span>.createElement(<span class="string">'div'</span>);_2s.innerHTML=<span class="string">'&lt;a href='</span>/<span class="string">'&gt;_1w'</span>;_2s=_2s.firstChild.href;<span class="keyword">var</span> _1H=_2s.match(<span class="regexp">/https?:/</span><span class="comment">//)[0];_2s=_2s.substr(_1H.length).toLowerCase();return function(_1H)&#123;for(var _1w=0;_1w&lt;_1H.length;_1w++)&#123;_1H[_1w]=_2s.charAt(_1H[_1w])&#125;;return _1H.join('')&#125;&#125;)(),function(_2s)&#123;return eval('String.fromCharCode('+_2s+')')&#125;],_1w=['C',[[-![]]+[-![]]+(8+[]+[]),(8+[]+[])+(-(+!![][&#123;&#125;])-[-![]-![]]+[])],'K',[(-[-![]-![]]+[]+[])+[(-[]+[--[]]&gt;&gt;--[])-(+!![][&#123;&#125;])-[-![]-![]]]],'2',[[6]+[6]],'IDW',(&#123;&#125;+[]+[[]][0]).charAt((-![]-![])*[(-![]-![]&lt;&lt;-![])]),'O',[[(-[]+[--[]]&gt;&gt;--[])-(+!![][&#123;&#125;])-[-![]-![]]]],[[(-[]+[--[]]&gt;&gt;--[])-(+!![][&#123;&#125;])-[-![]-![]]]+[--[]]],(!![][&#123;&#125;]+[]).charAt(3)+(-(+!![][&#123;&#125;])-[-![]-![]]+[]),[[6]+(8+[]+[])],'dt',[[-![]]+[-![]]+(-[-![]-![]]+[]+[]),[-![]]+[--[]]+[(+[])]],'r',[(-[-![]-![]]+[]+[])],[[6]+(8+[]+[])],'iz7',[(-[-![]-![]]+[]+[])+[(-[]+[--[]]&gt;&gt;--[])-(+!![][&#123;&#125;])-[-![]-![]]]],'2BU%',(-[-![]-~![]]+[]+[]),'D'];for(var _2s=0;_2s&lt;_1w.length;_2s++)&#123;_1w[_2s]=_1H[1,3,1,3,1,3,1,0,1,2,3,0,3,1,3,1,2,3,1,3,1,0,1][_2s]&#125;;return _1w.join('')&#125;</span></span><br></pre></td></tr></table></figure>

<p> 之后使用otto执行这个函数（或在js里执行，直接run获取结果也可），结果就是第二个cookie的后半段的值了。完整结果就是：<span class="label danger">__jsl_clearance=1585492297.69|0|CvTK%2BIDWOOHs4DdtqxrDiz7%2BU%3D</span></p>
<p> 补充：执行时可能还会遇到一些js错误，比如：</p>
 <span class="label warning">'window' is not defined</span>，<span class="label warning">'document' is not defined</span> 等
<p> （因为不是在浏览器环境下，无法使用DOM对象）,在js里给些默认值优雅避过就好，例如：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">docJs := <span class="string">"var window = &#123;&#125;; var document = &#123;createElement:function()&#123; return &#123;firstChild:&#123;href:'https://'&#125;, innerHTML:''&#125;&#125;&#125;;"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，把完整的cookie加到请求头中再发起一起请求，就可以获得200的正常返回了。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Cookie:__jsluid_h=<span class="number">988846693</span>f681c7e063343acefc11072;__jsl_clearance=<span class="number">1585492297.69</span>|<span class="number">0</span>|CvTK%<span class="number">2</span>BIDWOOHs4DdtqxrDiz7%<span class="number">2</span>BU%<span class="number">3</span>D</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Go goquery spider</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL：buffer_size相关配置</title>
    <url>/2020/03/01/Mysql_buffer_size/</url>
    <content><![CDATA[<p>MySQL中涉及到size的缓冲配置项有不少，有些配置对性能的影响还是较大的，这里简单介绍一下。</p>
<a id="more"></a>

<p>首先查一下带<span class="label info">buffer_size</span>相关的配置项，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;%buffer_size%&#39;;</span><br><span class="line">+-------------------------+----------+</span><br><span class="line">| Variable_name           | Value    |</span><br><span class="line">+-------------------------+----------+</span><br><span class="line">| bulk_insert_buffer_size | 8388608  |</span><br><span class="line">| innodb_log_buffer_size  | 16777216 | </span><br><span class="line">| innodb_sort_buffer_size | 1048576  |</span><br><span class="line">| join_buffer_size        | 262144   |</span><br><span class="line">| key_buffer_size         | 8388608  |</span><br><span class="line">| myisam_sort_buffer_size | 8388608  |</span><br><span class="line">| preload_buffer_size     | 32768    |</span><br><span class="line">| read_buffer_size        | 131072   |</span><br><span class="line">| read_rnd_buffer_size    | 262144   |</span><br><span class="line">| sort_buffer_size        | 262144   |</span><br><span class="line">+-------------------------+----------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><div style="width:100px">Variable_name</div></th>
<th><div style="width:40px">范围</div></th>
<th><div style="width:30px">是否动态参数</div></th>
<th><div style="width:35px">默认值</div></th>
<th><div style="width:35px">最小值</div></th>
<th><div style="width:55px">最大值</div></th>
<th><div style="width:150px">说明</div></th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>bulk_insert_buffer_size<br>(<span style="color:red">MyISAM专用</span>)</td>
<td>Global<br>Session</td>
<td>Yes</td>
<td>8MB</td>
<td>0</td>
<td>4GB(32 bit)<br>-(64 bit)</td>
<td>MyISAM批量插入非空表数据时使用的高速树状缓存区大小（以每个线程为单位）</td>
<td>-</td>
</tr>
<tr>
<td>innodb_log_buffer_size<br>(<span style="color:red">InnoDB专用</span>)</td>
<td>Global</td>
<td>Yes</td>
<td>16MB</td>
<td>1MB</td>
<td>4GB</td>
<td>InnoDB用来写入磁盘日志文件的缓冲区的字节大小</td>
<td>如果业务代码中比较多较大的事务处理，最好将该值调大一些，避免事务提交前频繁写入磁盘，节省磁盘I/O</td>
</tr>
<tr>
<td>innodb_sort_buffer_size<br>(<span style="color:red">InnoDB专用</span>)</td>
<td>Global</td>
<td>No</td>
<td>1MB</td>
<td>64KB</td>
<td>64MB</td>
<td>指定在创建InnoDB索引期间用于排序数据的排序缓冲区的大小</td>
<td>(1) 此排序区域<span class="label info">仅用于创建索引期间的合并排序</span>，而不用于以后的索引维护操作。在索引创建完成时释放缓冲区；<br>(2) 此选项的值还控制在联机DDL操作期间扩展临时日志文件以记录并发DML的数量；<br>(3) 在<span class="label info">创建索引</span>的<span class="label info">ALTER TABLE</span>或<span class="label info">CREATE TABLE</span>语句中，将分配<span class="label info">3个</span>缓冲区，每个缓冲区的大小由该选项定义。另外，将辅助指针分配给排序缓冲区中的行，以便排序可以在指针上运行(而不是在排序操作期间移动行)</td>
</tr>
<tr>
<td>join_buffer_size</td>
<td>Global<br>Session</td>
<td>Yes</td>
<td>256KB</td>
<td>128B</td>
<td>4GB(Windows)<br>4GB(32 bit)<br>-(64 bit)</td>
<td>用于普通索引(plain index)扫描、范围索引(range index)扫描和不使用索引执行全表扫描的联接(join)的缓冲区的最小大小</td>
<td>(1) 每两个表之间的全联接(full join)被分配1个join buffer，如果是多个表的复杂连接，需要多个join buffer。<br>(2) <span class="label info">最好保持全局设置较小</span>，如果全局大小大于使用它的大多数查询所需的大小，那么内存分配时间会导致显著的性能下降。<br>(3) 当使用<span class="label info">块嵌套循环</span>(Block Nested-Loop)时，较大的联接缓冲区可以在第一个表中所有行中的所有必需列都存储在联接缓冲区中的情况下发挥有益的作用。<br>(4) 当使用<span class="label info">批处理密钥访问</span>(Batched Key Access)时，join_buffer_size的值定义了向存储引擎发出的每个请求中密钥的批处理大小。缓冲区越大，对联接操作的右表的顺序访问就越多，这可以显著提高性能</td>
</tr>
<tr>
<td>key_buffer_size<br>(<span style="color:red">MyISAM专用</span>)</td>
<td>Global</td>
<td>Yes</td>
<td>8MB</td>
<td>8B</td>
<td>4GB(32 bit)<br><div style="width:55px">OS_PER_PROCESS_LIMIT(64 bit)</div></td>
<td><div style="width:150px">索引缓冲区（索引缓存），设置的最大值不要超过机器总内存的25%。可以通过<span style="font-size:0.6em">Key_reads/Key_read_requests</span>（应&lt;0.01），<span style="font-size:0.6em;">Key_writes/Key_write_requests</span>，检查索引缓冲的性能</div></td>
<td>使用中的缓冲区比例（近似值）：<br>1 - ((Key_blocks_unused * key_cache_block_size) / key_buffer_size)</td>
</tr>
<tr>
<td>myisam_sort_buffer_size<br>(<span style="color:red">MyISAM专用</span>)</td>
<td>Global<br>Session</td>
<td>Yes</td>
<td>8MB</td>
<td>4KB</td>
<td>4GB(32 bit)<br>-(64 bit)</td>
<td>在REPAIR TABLE期间对MyISAM索引排序或使用CREATE INDEX或ALTER TABLE创建索引时分配的缓冲区大小</td>
<td>-</td>
</tr>
<tr>
<td>preload_buffer_size</td>
<td>Global,<br>Session</td>
<td>Yes</td>
<td>32KB</td>
<td>1KB</td>
<td>1GB</td>
<td>预加载索引时分配的缓冲区大小</td>
<td>-</td>
</tr>
<tr>
<td>read_buffer_size</td>
<td>Global<br>Session</td>
<td>Yes</td>
<td>128KB</td>
<td>8200B</td>
<td>2GB</td>
<td>1. 对MyISAM表进行顺序扫描的每个线程都会为其扫描的每个表分配此大小（以字节为单位）的缓冲区。<br>2. 对于所有存储引擎：<br>(1) 在为ORDER BY排序行时，用于将索引缓存在临时文件（而不是临时表）中。<br>(2) 对于批量插入分区。<br>(3) 用于缓存嵌套查询的结果。</td>
<td>该值为4kb的倍数（如果不是会四舍五入取最近的）</td>
</tr>
<tr>
<td>read_rnd_buffer_size</td>
<td>Global,<br>Session</td>
<td>Yes</td>
<td>256KB</td>
<td>1B</td>
<td>2GB</td>
<td>该值用于从MyISAM表进行读取，并且对于任何存储引擎均用于多范围读取优化</td>
<td>当在键排序操作之后按排序顺序从MyISAM表中读取行时，将通过此缓冲区读取这些行以避免磁盘查找（将变量设置为较大的值可以大大提高ORDER BY性能。但是这是为每个客户端分配的缓冲区，因此不应将全局变量设置为较大的值，而是仅在需要运行大型查询的那些客户端中更改会话变量）</td>
</tr>
<tr>
<td>sort_buffer_size</td>
<td>Global<br>Session</td>
<td>Yes</td>
<td>256KB</td>
<td>32KB</td>
<td>4GB(32 bit)<br>-(64 bit)</td>
<td>每个必须执行排序的会话都会分配此大小的缓冲区</td>
<td>(1) 该参数是会话级的（每个session用到排序时都会分配），所以不应设置过大；<br>(2) SHOW GLOBAL STATUS时如果看到每秒有很多Sort_merge_passes，则可以考虑增加sort_buffer_size值来加快ORDER BY或GROUP BY操作，这些操作无法通过查询优化或改进的索引来改善</td>
</tr>
</tbody></table>
<p>补充：</p>
<table>
<thead>
<tr>
<th><div style="width:130px">Variable_name</div></th>
<th><div style="width:30px">范围</div></th>
<th><div style="width:30px">是否动态参数</div></th>
<th><div style="width:35px">默认值</div></th>
<th><div style="width:35px">最小值</div></th>
<th><div style="width:100px">最大值</div></th>
<th><div style="width:90px">说明</div></th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><div style="width:130px">innodb_buffer_pool_chunk_size</div></td>
<td>Global</td>
<td>No</td>
<td>128M</td>
<td>1M</td>
<td><div style="width:100px">innodb_buffer_pool_size / innodb_buffer_pool_instances（缓冲池大小/缓冲池实例个数）</div></td>
<td><div style="width:90px">对缓冲池分块以避免在调整缓冲池大小时复制缓冲池的全部页，这个值就是用来定义每块的大小</div></td>
<td>(1) 初始化时如果innodb_buffer_pool_chunk_size*缓冲池实例个数比当前的缓冲池大小还大，innodb_buffer_pool_chunk_size会被调整为：缓冲池大小/缓冲池实例个数；<br>(2) ==innodb_buffer_pool_size== 一定是等于innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances的，如果修改==innodb_buffer_pool_chunk_size==配置，初始化时也会自动调整innodb_buffer_pool_size大小为innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances。（所以调整innodb_buffer_pool_chunk_size配置时需要留心对缓冲池大小的影响）；<br>(3) 为避免潜在性能问题，不要让innodb_buffer_pool_instances的值超过1000</td>
</tr>
</tbody></table>
<blockquote>
<p>链接：<br><a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html</a><br><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux解决内存不够的利器 Swap相关介绍</title>
    <url>/2020/02/11/Swap/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>Linux将其物理RAM（随机访问内存）划分为称为页的内存块。Swap是将内存页复制到硬盘上预先配置的空间（称为<span class="label info">交换空间</span>）以释放该内存页的过程。物理内存和交换空间的总大小就是可用的虚拟内存量。</p>
</blockquote>

<a id="more"></a>

<!-- TOC -->

<ul>
<li><a href="#1-交换空间swap-space">1. 交换空间（Swap space）</a></li>
<li><a href="#2-交换分区swap-partition">2. 交换分区（Swap partition）</a></li>
<li><a href="#3-交换文件swap-file">3. 交换文件（Swap file）</a></li>
<li><a href="#4-性能">4. 性能</a><ul>
<li><a href="#41-两个影响swap性能的参数">4.1. 两个影响swap性能的参数</a></li>
<li><a href="#42-优先级">4.2. 优先级</a></li>
<li><a href="#43-使用zswap或zram">4.3. 使用zswap或zram</a></li>
<li><a href="#44-striping-">4.4. Striping (?)</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h3 id="1-交换空间（Swap-space）"><a href="#1-交换空间（Swap-space）" class="headerlink" title="1. 交换空间（Swap space）"></a>1. 交换空间（Swap space）</h3><ul>
<li>交换空间可以采用<span class="label warning">磁盘分区</span>或<span class="label warning">文件</span>的形式。交换空间可用于两个目的，即将虚拟内存扩展到已安装的物理内存（RAM）之外（也称为“enable swap”），也可用于磁盘挂起支持（suspend-to-disk support）。</li>
<li>启用交换是否有益取决于已安装的物理内存量以及运行所有所需程序所需的内存量。如果物理内存量小于所需的量，则启用交换是有益的。这样可以避免内存不足的情况，Linux内核的<span class="label warning">OOM killer</span>机制将通过杀死进程来自动尝试释放内存。要将虚拟内存量增加到所需的数量，请添加必要的差异作为交换空间。启用交换的最大缺点是<span class="label warning">性能较低</span>。</li>
<li>检查Swap状态：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapon -s</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -m <span class="comment">#free还指示内存是否不足，可以通过启用或增加Swap来补救。</span></span><br></pre></td></tr></table></figure>

<h3 id="2-交换分区（Swap-partition）"><a href="#2-交换分区（Swap-partition）" class="headerlink" title="2. 交换分区（Swap partition）"></a>2. 交换分区（Swap partition）</h3><ul>
<li>将分区设置为Linux交换区域（<span class="label danger">注：指定分区上的所有数据将丢失</span>）：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkswap / dev / sd xy</span><br></pre></td></tr></table></figure>

<ul>
<li>启用device进行分页：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapon /dev/sdxy</span><br></pre></td></tr></table></figure>

<ul>
<li>要在启动时启用此交换分区，添加以下内容到/etc/fstab：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">UUID=device_UUID none swap defaults 0 0 </span><br><span class="line"><span class="comment">#device_UUID是swap的UUID</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过systemd激活<br>systemd基于两种不同的机制激活交换分区。两者都是的可执行文件 <span class="label warning">/usr/lib/systemd/system-generators</span>。生成器在启动时运行，并创建用于安装的本机systemd单元。首先 <span class="label warning">systemd-fstab-generator</span>读取fstab，生成单元（包括用于交换的单元）。第二步，<span class="label warning">systemd-gpt-auto-generator</span>检查根磁盘以生成单元。它仅在GPT磁盘上运行，并且可以通过分区类型GUID识别交换分区。</li>
<li>禁用交换</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapoff / dev / sd xy</span><br><span class="line">swapoff -a  <span class="comment">#禁用所有交换空间</span></span><br></pre></td></tr></table></figure>

<h3 id="3-交换文件（Swap-file）"><a href="#3-交换文件（Swap-file）" class="headerlink" title="3. 交换文件（Swap file）"></a>3. 交换文件（Swap file）</h3><p><u><em>作为创建整个分区的替代方案，交换文件提供了动态更改大小的功能，并且更容易完全删除。</em></u></p>
<ul>
<li>手动创建</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对于Btrfs这种写时复制（copy-on-write）的文件系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#首先创建一个长度为零的文件</span></span><br><span class="line">truncate -s 0 /swapfile</span><br><span class="line"><span class="comment">#使用chattr对其设置 No_COW 属性</span></span><br><span class="line">chattr +C /swapfile</span><br><span class="line"><span class="comment">#禁用压缩</span></span><br><span class="line">btrfs property <span class="built_in">set</span> /swapfile compression none</span><br></pre></td></tr></table></figure>

<p><i><span class="label danger">注：自Linux内核版本5.0起，Btrfs开始支持交换文件，但有一定限制:<br> (1) 交换文件不能位于快照子卷上。正确的过程是创建一个新的子卷来放置交换文件。<br> (2) 它不支持跨多个设备的文件系统上的交换文件。</span></i></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用fallocate创建一个交换文件（M = Mebibytes，G = Gibibytes）</span></span><br><span class="line">fallocate -l 512M /swapfile</span><br><span class="line"><span class="comment">#注意： Fallocate可能会导致某些文件系统（例如F2FS）出现问题。作为替代，使用dd更可靠，但更慢</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/swapfile bs=1M count=512 status=progress</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置正确的权限（world-readable swap file是一个巨大的本地漏洞）：</span></span><br><span class="line">chmod 600 /swapfile</span><br><span class="line"></span><br><span class="line"><span class="comment">#格式化</span></span><br><span class="line">mkswap /swapfile</span><br><span class="line"></span><br><span class="line"><span class="comment">#激活</span></span><br><span class="line">swapon /swapfile</span><br><span class="line"></span><br><span class="line"><span class="comment">#编辑fstab配置，添加以下条目</span></span><br><span class="line">vim /etc/fstab</span><br><span class="line">/swapfile none swap defaults 0 0</span><br></pre></td></tr></table></figure>

<p><i><span class="label danger">注：交换文件必须由其在文件系统上的位置指定，而不是由其UUID或LABEL指定</span></i></p>
<ul>
<li>删除交换文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先关闭</span></span><br><span class="line">swapoff /swapfile</span><br><span class="line"><span class="comment">#再删除</span></span><br><span class="line">rm -f /swapfile</span><br><span class="line"><span class="comment">#最后从/etc/fstab中删除相关条目</span></span><br><span class="line">vim /etc/fstab</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>自动创建<br><u><em>systemd-swap是一个脚本，用于从zram交换、交换文件和交换分区创建混合交换空间。它与systemd项目无关。</em></u></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装systemd-swap包</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Nefelim4ag/systemd-swap.git</span><br><span class="line"><span class="built_in">cd</span> systemd-swap</span><br><span class="line">sudo make install</span><br><span class="line"><span class="comment">#设置/etc/systemd/swap.conf的交换文件分块配置</span></span><br><span class="line">swapfc_enabled=1</span><br><span class="line">? swapfc_force_preallocated=1 (如果日志一直报这个错误systemd-swap[..]: WARN: swapFC: ENOSPC，就开启)</span><br><span class="line"><span class="comment">#启动systemd-swap服务</span></span><br><span class="line">sudo service systemd-swap start</span><br></pre></td></tr></table></figure>

<h3 id="4-性能"><a href="#4-性能" class="headerlink" title="4. 性能"></a>4. 性能</h3><p><u><em>交换操作通常比直接访问RAM中的数据要慢得多。完全禁用交换以提高性能有时会导致性能下降，因为这会减少可用于VFS缓存的内存，从而导致更频繁、更昂贵的磁盘I/O。</em></u></p>
<h4 id="4-1-两个影响swap性能的参数"><a href="#4-1-两个影响swap性能的参数" class="headerlink" title="4.1. 两个影响swap性能的参数"></a>4.1. 两个影响swap性能的参数</h4><ul>
<li><strong>Swappiness</strong><br>swappiness sysctl参数表示内核对交换空间的偏好(或避免)。Swappiness的值可以在0到100之间，默认值是60。低值导致内核避免交换，高值导致内核尝试使用交换空间。在足够的内存上使用较低的值可以提高许多系统的响应能力。</li>
<li><strong>VFS cache pressure</strong><br>它控制内核回收用于缓存VFS caches的内存的趋势，而不是pagecache和swap。增加这个值会增加回收VFS缓存的速度。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#检查当前swappiness|vfs_cache_pressure值（或者可以查看文件/sys/fs/cgroup/memory/memory.swappiness或/proc/sys/vm/swappiness）</span></span><br><span class="line">sysctl vm.swappiness</span><br><span class="line">sysctl vm.vfs_cache_pressure</span><br><span class="line"></span><br><span class="line"><span class="comment">#临时设置（由于/proc组织性很差，仅出于兼容性目的而保留，因此建议使用/sys代替）</span></span><br><span class="line">sysctl -w vm.swappiness=10</span><br><span class="line">sysctl -w vm.vfs_cache_pressure=50</span><br><span class="line"></span><br><span class="line"><span class="comment">#永久设置</span></span><br><span class="line">vim /etc/sysctl.d/99-swappiness.conf</span><br><span class="line">vm.swappiness=10</span><br><span class="line">vm.vfs_cache_pressure=50</span><br></pre></td></tr></table></figure>

<h4 id="4-2-优先级"><a href="#4-2-优先级" class="headerlink" title="4.2. 优先级"></a>4.2. 优先级</h4><p>如果有多个交换文件或交换分区，则应考虑为每个交换区域分配一个优先级值（0到32767）。在使用优先级较低的交换区之前，系统将使用优先级较高的交换区。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例，有一个较快的磁盘（/dev/sda）和一个较慢的磁盘（/dev/sdb），为最快的设备上的交换区域分配更高的优先级（pri）</span></span><br><span class="line">/dev/sda1 none swap defaults,pri=100 0 0</span><br><span class="line">/dev/sdb2 none swap defaults,pri=10  0 0</span><br><span class="line"></span><br><span class="line"><span class="comment">#或通过swapon的--priority参数：</span></span><br><span class="line">swapon --priority 100 /dev/sda1</span><br></pre></td></tr></table></figure>

<h4 id="4-3-使用zswap或zram"><a href="#4-3-使用zswap或zram" class="headerlink" title="4.3. 使用zswap或zram"></a>4.3. 使用zswap或zram</h4><p>Zswap是Linux内核功能，为交换的页面提供压缩的回写缓存。这样可以提高性能并减少IO操作。ZRAM在内存中创建虚拟压缩的交换文件，以替代磁盘上的交换文件。</p>
<h4 id="4-4-Striping"><a href="#4-4-Striping" class="headerlink" title="4.4. Striping (?)"></a>4.4. Striping (?)</h4><p>出于交换性能的原因，没有必要使用RAID。内核本身可以在多个设备上进行stripe swapping，只要在/etc/fstab文件中赋予它们相同的优先级即可。</p>
<blockquote>
<p>链接：<br><a href="https://wiki.archlinux.org/index.php/Swap" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Swap</a><br><a href="https://www.linux.com/news/all-about-linux-swap-space" target="_blank" rel="noopener">https://www.linux.com/news/all-about-linux-swap-space</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Swap</tag>
        <tag>文档翻译</tag>
      </tags>
  </entry>
</search>
