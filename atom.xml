<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YourMutualFriend</title>
  
  <subtitle>第二基地</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-01T19:26:37.198Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>dony</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql频繁重启 问题解决</title>
    <link href="http://yoursite.com/2020/04/01/Mysql_shutdown/"/>
    <id>http://yoursite.com/2020/04/01/Mysql_shutdown/</id>
    <published>2020-03-31T18:46:01.000Z</published>
    <updated>2020-04-01T19:26:37.198Z</updated>
    
    <content type="html"><![CDATA[<p>最近每天晚上的定时任务都会跑失败，业务错误日志都是<span class="label danger">MySQL server has gone away</span>。去查MySQL的日志也没有对应的错误信息，只有启动日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020-01-19T07:04:07.434344Z 0 [System] [MY-010116] [Server] &#x2F;usr&#x2F;sbin&#x2F;mysqld (mysqld 8.0.18) starting as process 10717</span><br><span class="line">2020-01-19T07:04:09.716710Z 0 [System] [MY-010229] [Server] Starting crash recovery...</span><br><span class="line">2020-01-19T07:04:09.786959Z 0 [System] [MY-010232] [Server] Crash recovery finished.</span><br></pre></td></tr></table></figure><a id="more"></a><p>查看内核日志（dmesg |grep mysqld），发现是内存不够用直接被kill掉了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[5974675.178431] [32531]  1000 32531   343724   120571     343        0             0 mysqld</span><br><span class="line">[5974675.178504] Out of memory: Kill process 32531 (mysqld) score 476 or sacrifice child</span><br><span class="line">[5974675.180641] Killed process 32531 (mysqld) total-vm:1374896kB, anon-rss:482284kB, file-rss:0kB, shmem-rss:0kB</span><br></pre></td></tr></table></figure><p>我的服务器配置如下，可见资源非常紧张，然而运行一个几乎无人访问的<a href="https://prettycrazyjoey.cn/" target="_blank" rel="noopener"><span class="label info">小网站</span></a>应该也够了。</p><table><thead><tr><th>操作系统</th><th>CPU</th><th>内存</th><th>公网带宽</th><th>硬盘</th></tr></thead><tbody><tr><td>CentOS 7.5 64位</td><td>1核</td><td>1GB</td><td>1Mbps</td><td>50GB</td></tr></tbody></table><p>但问题还是要解决的，不然每天<i>free -m</i>提心吊胆的实在是太折磨。我最初想到的方法是调整MySQL配置和定期清理缓存，经过一番查询和亲自实践才发现最有效的办法其实是使用交换文件作为虚拟内存。总之，这里还是记录和总结一下具体的解决方法吧。</p><h4 id="1-调整MySQL配置"><a href="#1-调整MySQL配置" class="headerlink" title="1. 调整MySQL配置"></a>1. 调整MySQL配置</h4><p>MySQL刚安装的时候就已经把innodb_buffer_pool_size调整到了80M，只好继续调低，目前配置64M（<strong>注意</strong>：要同时修改<span class="label primary">innodb_buffer_pool_chunk_size</span>的大小，该值和innodb_buffer_pool_size一样都是默认128M。它相当于缓冲池的最小单位，如果缓冲池总大小比该值还小，在初始化时实际上不会改变）。但感觉这应该节省不了多少内存，只好继续从别的配置项着手。有关buffer_size相关的各配置项的详细说明请参见 <a href="/2020/03/01/Mysql_buffer_size/"><span class="label info">《MySQL：buffer_size相关配置》</span></a>。</p><p>实际上，以我当前的服务器条件，在修改配置上节省出更多的内存，优化的空间已经非常小，且大部分MySQL的默认配置已经是相对最优的了。所以还是应该换个思路。</p><h4 id="2-使用Swap虚拟内存"><a href="#2-使用Swap虚拟内存" class="headerlink" title="2. 使用Swap虚拟内存"></a>2. 使用Swap虚拟内存</h4><p><u><em>Linux将其物理RAM（随机访问内存）划分为称为页的内存块。Swap是将内存页复制到硬盘上预先配置的空间（称为交换空间）以释放该内存页的过程。物理内存和交换空间的总大小就是可用的虚拟内存量。</em></u></p><p>更详细一些的介绍可以参考这篇，<a href="/2020/02/11/Swap/"><span class="label info">Swap介绍与应用</span></a>。</p><p>最快捷的方法就是安装systemd-swap来使用交换空间，这是一个用来管理swap的脚本，只要简单几步就可以将复杂的创建和配置过程搞定，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装systemd-swap包</span></span><br><span class="line">git clone https://github.com/Nefelim4ag/systemd-swap.git</span><br><span class="line">cd systemd-swap</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置/etc/systemd/swap.conf的交换文件分块配置</span></span><br><span class="line">swapfc_enabled=1</span><br><span class="line">swapfc_force_preallocated=1 (如果日志一直报这个错误systemd-swap[..]: WARN: swapFC: ENOSPC，就开启)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动systemd-swap服务</span></span><br><span class="line">sudo service systemd-swap start</span><br></pre></td></tr></table></figure><h4 id="【后记】"><a href="#【后记】" class="headerlink" title="【后记】"></a>【后记】</h4><p>在使用Swap之前基本上MySQL每天都会重启一两次，使用之后就没再发生过重启的情况了，到目前也已经将近两个月过去了，而数据也是在不断增加的，实践证明，在内存空间不是十分富裕的情况下使用Swap交换空间作为虚拟内存，是非常有效的措施。</p><p>当前的内存使用情况如下：</p><table><thead><tr><th>-</th><th>total</th><th>used</th><th>free</th><th>shared</th><th>buff/cache</th><th>available</th></tr></thead><tbody><tr><td>Mem:</td><td>991</td><td>533</td><td>66</td><td>0</td><td>392</td><td>278</td></tr><tr><td>Swap:</td><td>1023</td><td>566</td><td>457</td><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近每天晚上的定时任务都会跑失败，业务错误日志都是&lt;span class=&quot;label danger&quot;&gt;MySQL server has gone away&lt;/span&gt;。去查MySQL的日志也没有对应的错误信息，只有启动日志：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2020-01-19T07:04:07.434344Z 0 [System] [MY-010116] [Server] &amp;#x2F;usr&amp;#x2F;sbin&amp;#x2F;mysqld (mysqld 8.0.18) starting as process 10717&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2020-01-19T07:04:09.716710Z 0 [System] [MY-010229] [Server] Starting crash recovery...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2020-01-19T07:04:09.786959Z 0 [System] [MY-010232] [Server] Crash recovery finished.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="问题解决" scheme="http://yoursite.com/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="网站开发" scheme="http://yoursite.com/tags/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/"/>
    
      <category term="实战总结" scheme="http://yoursite.com/tags/%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Go爬虫 http code 521问题解决</title>
    <link href="http://yoursite.com/2020/03/29/Goquery_521/"/>
    <id>http://yoursite.com/2020/03/29/Goquery_521/</id>
    <published>2020-03-29T15:48:56.000Z</published>
    <updated>2020-04-01T18:57:55.085Z</updated>
    
    <content type="html"><![CDATA[<p>今天在帮朋友爬取好大夫网站的时候，一直被卡在请求医生个人主页上。打印错误信息发现返回的http code都是521，而直接打开网页又是正常的。对于这个状态码我并不了解，但是前功尽弃又实在不甘心，只好Google寻找答案。</p><a id="more"></a><p>最终是这篇文章帮到了我：<a href="https://blog.csdn.net/wangdepei/article/details/84798601" target="_blank" rel="noopener"><span class="label info">HTTP STATUS CODE: 521的解决办法</span></a></p><p>我在Postman和Chrome浏览器上还原这个场景，果然和文章描述非常一致。</p><p><a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="noopener"><span class="label info">List of HTTP status codes</span></a> 中对http code 521的定义是：</p><blockquote><p>Web Server Is Down: The origin server has refused the connection from Cloudflare.</p></blockquote><p>实际上，这是网站防爬虫的一种措施。了解了这一措施的执行方式，也就可以抽丝剥茧一步一步去解决这个问题了。</p><p>具体的分析过程就不赘述了，直接参考上面那篇文章即可，这里我简单记录一下在代码中解决的完整过程：</p><ol><li><p>发起一个请求。这是正常操作，但是这一次请求肯定不能得到有效的页面，不过都是必走的过程，无法避免。<br> (1) 先清除cookie（在postman下使用带cookie的请求得到的js代码无法解析，而浏览器是可以正常跳转的，这里不深究了，直接清掉以绝后患）;</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.Header.Del(<span class="string">"Cookie"</span>)</span><br></pre></td></tr></table></figure><p> (2) 设置该请求的Connection为keep-alive（<span class="label danger">第二个请求要使用同一个req发起，所以这个请求是不能close掉的</span>）</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">req.Header.Add(<span class="string">"Connection"</span>, <span class="string">"keep-alive"</span>)</span><br><span class="line">req.Close = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p> (3) 发起请求并拿到响应结果（略）</p></li><li><p>获取响应头的Set-Cookie属性，打印出来该值如下，这里只需要拿到__jsluid_h的值即可：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__jsluid_h=a44718981efe4f7006fece7f82d69844%&#125;; max-age=<span class="number">31536000</span>; path=<span class="regexp">/; HttpOnly</span></span><br></pre></td></tr></table></figure></li><li><p>获取response body，看起来像是一段js代码和一堆乱码组成，我们只需要<span class="label primary">script</span>标签之间的js代码 ，打印输出如下：<br> <i style="font-size:12px;"> <div class="note default">            <p>var x=”captcha@charAt@@@toLowerCase@@@onreadystatechange@Mar@Expires@firstChild@@@@chars@innerHTML@40@parseInt@if@while@@@createElement@@H@String@0xEDB88320@join@fromCharCode@@30@a@@@div@20@match@Mon@addEventListener@@DOMContentLoaded@split@17@19@pathname@@@challenge@rOm9XFMtA3QKV7nYsPGT4lifyWwkq5vcjH2IdxUoCbhERLaz81DNB6@Path@else@GMT@href@toString@e@function@@0xFF@false@@0@RegExp@@catch@@JgSe0upZ@Array@@@27@@@@<em>_jsl_clearance@3@@substr@3D@document@@@return@k7zgL@location@g@cookie@@replace@window@2@1500@h@67Yn@@eval@new@search@@8@try@1585586419@@6@@charCodeAt@@reverse@f@d@var@@attachEvent@setTimeout@@@n@https@for@@@@length@@36@1@@@2Fs”.replace(/@<em>$/,””).split(“@”),y=”2u o=1g(){2x(‘24.1d=24.15+24.2h.28(/[\?|&amp;]1-18/,\‘\‘)’,2b);1D.26=’1y=2l.1u|1l|’+(1g(){2u y=[1g(o){22 o},1g(y){22 y},(1g(){2u o=1D.n(‘z’);o.g=’&lt;w 1d=\‘/\‘&gt;7</w>‘;o=o.b.1d;2u y=o.B(/2B?:\/\//)[1l];o=o.1B(y.32).5();22 1g(y){2C(2u 7=1l;7&lt;y.32;7++){y[7]=o.2(y[7])};22 y.s(‘’)}})(),1g(o){22 2f(‘q.t(‘+o+’)’)}],7=[[(-<del>[-</del>![]-<del>![]]+[]+[])+[(-</del>[]+[-<del>-</del>[]]&gt;&gt;-<del>-</del>[])-<del>(+!![][{}])-</del>[-<del>![]-</del>![]]]],[-<del>-</del>[]],[[2n]+[2n],[(-<del>[]+[-</del>-<del>[]]&gt;&gt;-</del>-<del>[])-</del>(+!![][{}])-<del>[-</del>![]-<del>![]]]+[(+[])]],’2c’,[[2n]+(-</del>(2j)+[])],’2A’,[(2j+[]+[])+(2j+[]+[])],[2n]+((-<del>(+!![][{}])+[</del>{}])/[(-<del>![]&lt;&lt;-</del>![])]+[[]][1l]),’p%38’,[-<del>-</del>[]],[[-<del>![]]+[-</del>![]]+(-<del>[-</del>![]-<del>![]]+[]+[])],’2d’,[[-</del>![]]],’23’,[(-<del>[-</del>![]-<del>![]]+[]+[]),((-</del>(+!![][{}])+[<del>{}])/[(-</del>![]&lt;&lt;-<del>![])]+[[]][1l])],(!-{}+[]).2(</del>[]),’25’,[(-<del>[-</del>![]-<del>![]]+[]+[])+[(-</del>[]+[-<del>-</del>[]]&gt;&gt;-<del>-</del>[])-<del>(+!![][{}])-</del>[-<del>![]-</del>![]]]],’1C’];2C(2u o=1l;o&lt;7.32;o++){7[o]=y<a href="7[o]">[1z,1l,1z,35,1z,35,1z,1l,35,1l,1z,35,2a,35,2a,1l,35,1z,35][o]</a>};22 7.s(‘’)})()+’;a=C, v-9-A 13:h:14 1c;1a=/;’};j((1g(){2k{22 !!29.D;}1o(1f){22 1j;}})()){1D.D(‘11’,o,1j)}1b{1D.2w(‘8’,o)}”,f=function(x,y){var a=0,b=0,c=0;x=x.split(“”);y=y||99;while((a=x.shift())&amp;&amp;(b=a.charCodeAt(0)-77.5))c=(Math.abs(b)&lt;13?(b+48.5):parseInt(a,36))+y</em>c;return c},z=f(y.match(/\w/g).sort(function(x,y){return f(x)-f(y)}).pop());while(z++)try{ console.log(y.replace(/\b\w+\b/g, function(y){return x[f(y,z)-1]||(“</em>“+y)}));break}catch(_){}</p>          </div></i></p></li><li><p>接下来要执行上面这段js，这里需要用到运行js代码的go包：<a href="https://github.com/robertkrimen/otto" target="_blank" rel="noopener"><span class="label info">github.com/robertkrimen/otto</span></a>，使用方法也很简单，直接参考文档就好。但是上面这段代码还是存在一些问题，直接运行是拿不到任何返回结果的。我的解决方式如下，先使用<span class="label primary">console.log()</span>输出控制台日志，再在js代码里加一段代码，返回最后一条log结果。代码如下：</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先把上段js代码中的eval替换成console.log</span></span><br><span class="line">js = strings.Replace(js, <span class="string">"eval("</span>, <span class="string">" console.log("</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">// 加入一段返回log的js代码</span></span><br><span class="line">consoleJs := <span class="string">"var lastLog = \"\";console.oldLog = console.log;console.log = function(str) &#123;console.oldLog(str);lastLog = str;&#125;;"</span></span><br><span class="line"><span class="comment">// 拼接起来，并执行最终这段js</span></span><br><span class="line">js = consoleJs + js</span><br></pre></td></tr></table></figure></li><li><p>执行后得到的第二段js代码如下，结果依然非常乱，其他的不用管，直接找到我们需要的第二个cookie的key，也就是<span class="label danger">__jsl_clearance</span>，=后面的内容就是我们需要的值：1585492297.69|0| + function(){}，前半段很好说，主要是后半段的function的内容看起来十分隐晦，不过既然是js代码，我们还是可以通过运行它来获取答案的。</p><p> <i style="font-size:12px"> <div class="note default">            <p>var _o=function(){setTimeout(‘location.href=location.pathname+location.search.replace(/[?|&amp;]captcha-challenge/,&#39;&#39;)’,1500);<span class="label danger">document.cookie=__jsl_clearance=1585586419.27|0|</span>+(function(){var _y=[function(_o){return _o},function(_y){return _y},(function(){var _o=document.createElement(‘div’);_o.innerHTML=’&lt;a href=&#39;/&#39;&gt;_7</a>‘;_o=_o.firstChild.href;var _y=_o.match(/https?:///)[0];_o=_o.substr(_y.length).toLowerCase();return function(_y){for(var _7=0;_7&lt;_y.length;_7++){_y[_7]=_o.charAt(_y[_7])};return _y.join(‘’)}})(),function(_o){return eval(‘String.fromCharCode(‘+_o+’)’)}],_7=[[(-<del>[-</del>![]-<del>![]]+[]+[])+[(-</del>[]+[-<del>-</del>[]]&gt;&gt;-<del>-</del>[])-<del>(+!![][{}])-</del>[-<del>![]-</del>![]]]],[-<del>-</del>[]],[[6]+[6],[(-<del>[]+[-</del>-<del>[]]&gt;&gt;-</del>-<del>[])-</del>(+!![][{}])-<del>[-</del>![]-<del>![]]]+[(+[])]],’h’,[[6]+(-</del>(8)+[])],’n’,[(8+[]+[])+(8+[]+[])],[6]+((-<del>(+!![][{}])+[</del>{}])/[(-<del>![]&lt;&lt;-</del>![])]+[[]][0]),’H%2Fs’,[-<del>-</del>[]],[[-<del>![]]+[-</del>![]]+(-<del>[-</del>![]-<del>![]]+[]+[])],’67Yn’,[[-</del>![]]],’k7zgL’,[(-<del>[-</del>![]-<del>![]]+[]+[]),((-</del>(+!![][{}])+[<del>{}])/[(-</del>![]&lt;&lt;-<del>![])]+[[]][0])],(!-{}+[]).charAt(</del>[]),’g’,[(-<del>[-</del>![]-<del>![]]+[]+[])+[(-</del>[]+[-<del>-</del>[]]&gt;&gt;-<del>-</del>[])-<del>(+!![][{}])-</del>[-<del>![]-</del>![]]]],’3D’];for(var _o=0;_o&lt;_7.length;_o++){_7[_o]=_y<a href="_7[_o]">[3,0,3,1,3,1,3,0,1,0,3,1,2,1,2,0,1,3,1][_o]</a>};return _7.join(‘’)})()+’;Expires=Mon, 30-Mar-20 17:40:19 GMT;Path=/;’};if((function(){try{return !!window.addEventListener;}catch(e){return false;}})()){document.addEventListener(‘DOMContentLoaded’,_o,false)}else{document.attachEvent(‘onreadystatechange’,_o)}</p>          </div> </i></p><p> 以下就是截取出来的cookie值后半段的js代码了（因为在原代码段中这是个闭包函数，截取出来是无法直接执行的，所以把function中的内容单独拿出来，定义为一个新函数f。</p><p> <i style="font-size:12px"> <div class="note default">            <p>function f(){var _y=[function(_o){return _o},function(_y){return _y},(function(){var _o=document.createElement(‘div’);_o.innerHTML=’&lt;a href=&#39;/&#39;&gt;_7</a>‘;_o=_o.firstChild.href;var _y=_o.match(/https?:///)[0];_o=_o.substr(_y.length).toLowerCase();return function(_y){for(var _7=0;_7&lt;_y.length;_7++){_y[_7]=_o.charAt(_y[_7])};return _y.join(‘’)}})(),function(_o){return eval(‘String.fromCharCode(‘+_o+’)’)}],_7=[[(-<del>[-</del>![]-<del>![]]+[]+[])+[(-</del>[]+[-<del>-</del>[]]&gt;&gt;-<del>-</del>[])-<del>(+!![][{}])-</del>[-<del>![]-</del>![]]]],[-<del>-</del>[]],[[6]+[6],[(-<del>[]+[-</del>-<del>[]]&gt;&gt;-</del>-<del>[])-</del>(+!![][{}])-<del>[-</del>![]-<del>![]]]+[(+[])]],’h’,[[6]+(-</del>(8)+[])],’n’,[(8+[]+[])+(8+[]+[])],[6]+((-<del>(+!![][{}])+[</del>{}])/[(-<del>![]&lt;&lt;-</del>![])]+[[]][0]),’H%2Fs’,[-<del>-</del>[]],[[-<del>![]]+[-</del>![]]+(-<del>[-</del>![]-<del>![]]+[]+[])],’67Yn’,[[-</del>![]]],’k7zgL’,[(-<del>[-</del>![]-<del>![]]+[]+[]),((-</del>(+!![][{}])+[<del>{}])/[(-</del>![]&lt;&lt;-<del>![])]+[[]][0])],(!-{}+[]).charAt(</del>[]),’g’,[(-<del>[-</del>![]-<del>![]]+[]+[])+[(-</del>[]+[-<del>-</del>[]]&gt;&gt;-<del>-</del>[])-<del>(+!![][{}])-</del>[-<del>![]-</del>![]]]],’3D’];for(var _o=0;_o&lt;_7.length;_o++){_7[_o]=_y<a href="_7[_o]">[3,0,3,1,3,1,3,0,1,0,3,1,2,1,2,0,1,3,1][_o]</a>};return _7.join(‘’)} </p>          </div> </i></p><p> 尝试执行这段js，问题又出现了。开始报<span class="label warning">'document' is not defined</span> 等错误。报错主要集中在这一部分中：<span class="label danger"> var _o=document.createElement(div);_o.innerHTML=<a href='/'>_7</a>;_o=_o.firstChild.href;var _y=_o.match(/https?:\/\//)[0];_o=_o.substr(_y.length).toLowerCase();</span>，无论你熟不熟悉js都应该看得出这段看似冗长的代码实际上不过是在给一个变量赋值。<br> 但是这些错误很难破解，因为<span class="label primary">不是在浏览器环境下，无法使用DOM对象</span>。不过都想到这里了，那不妨试试在浏览器下执行它会是什么结果。打开Chrome控制台执行这部分代码，并输出最终的这个变量值。<br> 看到结果后我不禁长舒一口气，竟然是当前页面的域名。既然如此那就不用绞尽脑汁去想如何解决js报错了，直接<span class="label primary">将这个变量赋值为当前域名</span>就好了。<br> 之后使用otto执行这个函数（或在js里执行，直接run()获取结果都可）。这样就拿到第二个cookie的后半段的值了。和前半部分拼接起来就是我们要的答案：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__jsl_clearance=<span class="number">1585492297.69</span>|<span class="number">0</span>|CvTK%<span class="number">2</span>BIDWOOHs4DdtqxrDiz7%<span class="number">2</span>BU%<span class="number">3</span>D</span><br></pre></td></tr></table></figure><p> 补充：如果还遇到类似<span class="label warning">'window' is not defined</span>的报错，直接在前面创建一个默认对象就好，如下</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preJs := <span class="string">"var window = &#123;&#125;;"</span></span><br></pre></td></tr></table></figure></li><li><p>最后，把完整的cookie加到请求头中再发起一起请求，就可以获得200的正常返回了。</p> <div class="note success">            <p>Cookie: <strong>jsluid_h=a44718981efe4f7006fece7f82d69844;</strong>jsl_clearance=1585586419.27|0|%2BFhEnX65H%2Fs2q67Ynuk7zgLietg%3D</p>          </div></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在帮朋友爬取好大夫网站的时候，一直被卡在请求医生个人主页上。打印错误信息发现返回的http code都是521，而直接打开网页又是正常的。对于这个状态码我并不了解，但是前功尽弃又实在不甘心，只好Google寻找答案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="问题解决" scheme="http://yoursite.com/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
      <category term="实战总结" scheme="http://yoursite.com/tags/%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="网络爬虫" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>MySQL：buffer_size相关配置</title>
    <link href="http://yoursite.com/2020/03/01/Mysql_buffer_size/"/>
    <id>http://yoursite.com/2020/03/01/Mysql_buffer_size/</id>
    <published>2020-03-01T13:02:48.000Z</published>
    <updated>2020-04-01T18:53:23.536Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL中涉及到size的缓冲配置项有不少，有些配置对性能的影响还是较大的，这里简单介绍一下。</p><a id="more"></a><p>首先查一下带<span class="label info">buffer_size</span>相关的配置项，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;%buffer_size%&#39;;</span><br><span class="line">+-------------------------+----------+</span><br><span class="line">| Variable_name           | Value    |</span><br><span class="line">+-------------------------+----------+</span><br><span class="line">| bulk_insert_buffer_size | 8388608  |</span><br><span class="line">| innodb_log_buffer_size  | 16777216 | </span><br><span class="line">| innodb_sort_buffer_size | 1048576  |</span><br><span class="line">| join_buffer_size        | 262144   |</span><br><span class="line">| key_buffer_size         | 8388608  |</span><br><span class="line">| myisam_sort_buffer_size | 8388608  |</span><br><span class="line">| preload_buffer_size     | 32768    |</span><br><span class="line">| read_buffer_size        | 131072   |</span><br><span class="line">| read_rnd_buffer_size    | 262144   |</span><br><span class="line">| sort_buffer_size        | 262144   |</span><br><span class="line">+-------------------------+----------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><table><thead><tr><th><div style="width:100px">Variable_name</div></th><th><div style="width:40px">范围</div></th><th><div style="width:30px">是否动态参数</div></th><th><div style="width:35px">默认值</div></th><th><div style="width:35px">最小值</div></th><th><div style="width:55px">最大值</div></th><th><div style="width:150px">说明</div></th><th>备注</th></tr></thead><tbody><tr><td>bulk_insert_buffer_size<br>(<span style="color:red">MyISAM专用</span>)</td><td>Global<br>Session</td><td>Yes</td><td>8MB</td><td>0</td><td>4GB(32 bit)<br>-(64 bit)</td><td>MyISAM批量插入非空表数据时使用的高速树状缓存区大小（以每个线程为单位）</td><td>-</td></tr><tr><td>innodb_log_buffer_size<br>(<span style="color:red">InnoDB专用</span>)</td><td>Global</td><td>Yes</td><td>16MB</td><td>1MB</td><td>4GB</td><td>InnoDB用来写入磁盘日志文件的缓冲区的字节大小</td><td>如果业务代码中比较多较大的事务处理，最好将该值调大一些，避免事务提交前频繁写入磁盘，节省磁盘I/O</td></tr><tr><td>innodb_sort_buffer_size<br>(<span style="color:red">InnoDB专用</span>)</td><td>Global</td><td>No</td><td>1MB</td><td>64KB</td><td>64MB</td><td>指定在创建InnoDB索引期间用于排序数据的排序缓冲区的大小</td><td>(1) 此排序区域<span class="label info">仅用于创建索引期间的合并排序</span>，而不用于以后的索引维护操作。在索引创建完成时释放缓冲区；<br>(2) 此选项的值还控制在联机DDL操作期间扩展临时日志文件以记录并发DML的数量；<br>(3) 在<span class="label info">创建索引</span>的<span class="label info">ALTER TABLE</span>或<span class="label info">CREATE TABLE</span>语句中，将分配<span class="label info">3个</span>缓冲区，每个缓冲区的大小由该选项定义。另外，将辅助指针分配给排序缓冲区中的行，以便排序可以在指针上运行(而不是在排序操作期间移动行)</td></tr><tr><td>join_buffer_size</td><td>Global<br>Session</td><td>Yes</td><td>256KB</td><td>128B</td><td>4GB(Windows)<br>4GB(32 bit)<br>-(64 bit)</td><td>用于普通索引(plain index)扫描、范围索引(range index)扫描和不使用索引执行全表扫描的联接(join)的缓冲区的最小大小</td><td>(1) 每两个表之间的全联接(full join)被分配1个join buffer，如果是多个表的复杂连接，需要多个join buffer。<br>(2) <span class="label info">最好保持全局设置较小</span>，如果全局大小大于使用它的大多数查询所需的大小，那么内存分配时间会导致显著的性能下降。<br>(3) 当使用<span class="label info">块嵌套循环</span>(Block Nested-Loop)时，较大的联接缓冲区可以在第一个表中所有行中的所有必需列都存储在联接缓冲区中的情况下发挥有益的作用。<br>(4) 当使用<span class="label info">批处理密钥访问</span>(Batched Key Access)时，join_buffer_size的值定义了向存储引擎发出的每个请求中密钥的批处理大小。缓冲区越大，对联接操作的右表的顺序访问就越多，这可以显著提高性能</td></tr><tr><td>key_buffer_size<br>(<span style="color:red">MyISAM专用</span>)</td><td>Global</td><td>Yes</td><td>8MB</td><td>8B</td><td>4GB(32 bit)<br><div style="width:55px">OS_PER_PROCESS_LIMIT(64 bit)</div></td><td><div style="width:150px">索引缓冲区（索引缓存），设置的最大值不要超过机器总内存的25%。可以通过<span style="font-size:0.6em">Key_reads/Key_read_requests</span>（应&lt;0.01），<span style="font-size:0.6em;">Key_writes/Key_write_requests</span>，检查索引缓冲的性能</div></td><td>使用中的缓冲区比例（近似值）：<br>1 - ((Key_blocks_unused * key_cache_block_size) / key_buffer_size)</td></tr><tr><td>myisam_sort_buffer_size<br>(<span style="color:red">MyISAM专用</span>)</td><td>Global<br>Session</td><td>Yes</td><td>8MB</td><td>4KB</td><td>4GB(32 bit)<br>-(64 bit)</td><td>在REPAIR TABLE期间对MyISAM索引排序或使用CREATE INDEX或ALTER TABLE创建索引时分配的缓冲区大小</td><td>-</td></tr><tr><td>preload_buffer_size</td><td>Global,<br>Session</td><td>Yes</td><td>32KB</td><td>1KB</td><td>1GB</td><td>预加载索引时分配的缓冲区大小</td><td>-</td></tr><tr><td>read_buffer_size</td><td>Global<br>Session</td><td>Yes</td><td>128KB</td><td>8200B</td><td>2GB</td><td>1. 对MyISAM表进行顺序扫描的每个线程都会为其扫描的每个表分配此大小（以字节为单位）的缓冲区。<br>2. 对于所有存储引擎：<br>(1) 在为ORDER BY排序行时，用于将索引缓存在临时文件（而不是临时表）中。<br>(2) 对于批量插入分区。<br>(3) 用于缓存嵌套查询的结果。</td><td>该值为4kb的倍数（如果不是会四舍五入取最近的）</td></tr><tr><td>read_rnd_buffer_size</td><td>Global,<br>Session</td><td>Yes</td><td>256KB</td><td>1B</td><td>2GB</td><td>该值用于从MyISAM表进行读取，并且对于任何存储引擎均用于多范围读取优化</td><td>当在键排序操作之后按排序顺序从MyISAM表中读取行时，将通过此缓冲区读取这些行以避免磁盘查找（将变量设置为较大的值可以大大提高ORDER BY性能。但是这是为每个客户端分配的缓冲区，因此不应将全局变量设置为较大的值，而是仅在需要运行大型查询的那些客户端中更改会话变量）</td></tr><tr><td>sort_buffer_size</td><td>Global<br>Session</td><td>Yes</td><td>256KB</td><td>32KB</td><td>4GB(32 bit)<br>-(64 bit)</td><td>每个必须执行排序的会话都会分配此大小的缓冲区</td><td>(1) 该参数是会话级的（每个session用到排序时都会分配），所以不应设置过大；<br>(2) SHOW GLOBAL STATUS时如果看到每秒有很多Sort_merge_passes，则可以考虑增加sort_buffer_size值来加快ORDER BY或GROUP BY操作，这些操作无法通过查询优化或改进的索引来改善</td></tr></tbody></table><p>补充：</p><table><thead><tr><th><div style="width:130px">Variable_name</div></th><th><div style="width:30px">范围</div></th><th><div style="width:30px">是否动态参数</div></th><th><div style="width:35px">默认值</div></th><th><div style="width:35px">最小值</div></th><th><div style="width:100px">最大值</div></th><th><div style="width:90px">说明</div></th><th>备注</th></tr></thead><tbody><tr><td><div style="width:130px">innodb_buffer_pool_chunk_size</div></td><td>Global</td><td>No</td><td>128M</td><td>1M</td><td><div style="width:100px">innodb_buffer_pool_size / innodb_buffer_pool_instances（缓冲池大小/缓冲池实例个数）</div></td><td><div style="width:90px">对缓冲池分块以避免在调整缓冲池大小时复制缓冲池的全部页，这个值就是用来定义每块的大小</div></td><td>(1) 初始化时如果innodb_buffer_pool_chunk_size*缓冲池实例个数比当前的缓冲池大小还大，innodb_buffer_pool_chunk_size会被调整为：缓冲池大小/缓冲池实例个数；<br>(2) ==innodb_buffer_pool_size== 一定是等于innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances的，如果修改==innodb_buffer_pool_chunk_size==配置，初始化时也会自动调整innodb_buffer_pool_size大小为innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances。（所以调整innodb_buffer_pool_chunk_size配置时需要留心对缓冲池大小的影响）；<br>(3) 为避免潜在性能问题，不要让innodb_buffer_pool_instances的值超过1000</td></tr></tbody></table><blockquote><p>链接：<br><a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html</a><br><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL中涉及到size的缓冲配置项有不少，有些配置对性能的影响还是较大的，这里简单介绍一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="文档翻译" scheme="http://yoursite.com/tags/%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Swap介绍与应用</title>
    <link href="http://yoursite.com/2020/02/11/Swap/"/>
    <id>http://yoursite.com/2020/02/11/Swap/</id>
    <published>2020-02-10T17:46:38.000Z</published>
    <updated>2020-04-01T19:01:58.445Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Linux将其物理RAM（随机访问内存）划分为称为页的内存块。Swap是将内存页复制到硬盘上预先配置的空间（称为<span class="label info">交换空间</span>）以释放该内存页的过程。物理内存和交换空间的总大小就是可用的虚拟内存量。</p></blockquote><a id="more"></a><!-- TOC --><ul><li><a href="#1-交换空间swap-space">1. 交换空间（Swap space）</a></li><li><a href="#2-交换分区swap-partition">2. 交换分区（Swap partition）</a></li><li><a href="#3-交换文件swap-file">3. 交换文件（Swap file）</a></li><li><a href="#4-性能">4. 性能</a><ul><li><a href="#41-两个影响swap性能的参数">4.1. 两个影响swap性能的参数</a></li><li><a href="#42-优先级">4.2. 优先级</a></li><li><a href="#43-使用zswap或zram">4.3. 使用zswap或zram</a></li><li><a href="#44-striping-">4.4. Striping (?)</a></li></ul></li></ul><!-- /TOC --><h3 id="1-交换空间（Swap-space）"><a href="#1-交换空间（Swap-space）" class="headerlink" title="1. 交换空间（Swap space）"></a>1. 交换空间（Swap space）</h3><ul><li>交换空间可以采用<span class="label warning">磁盘分区</span>或<span class="label warning">文件</span>的形式。交换空间可用于两个目的，即将虚拟内存扩展到已安装的物理内存（RAM）之外（也称为“enable swap”），也可用于磁盘挂起支持（suspend-to-disk support）。</li><li>启用交换是否有益取决于已安装的物理内存量以及运行所有所需程序所需的内存量。如果物理内存量小于所需的量，则启用交换是有益的。这样可以避免内存不足的情况，Linux内核的<span class="label warning">OOM killer</span>机制将通过杀死进程来自动尝试释放内存。要将虚拟内存量增加到所需的数量，请添加必要的差异作为交换空间。启用交换的最大缺点是<span class="label warning">性能较低</span>。</li><li>检查Swap状态：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon -s</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m <span class="comment">#free还指示内存是否不足，可以通过启用或增加Swap来补救。</span></span><br></pre></td></tr></table></figure><h3 id="2-交换分区（Swap-partition）"><a href="#2-交换分区（Swap-partition）" class="headerlink" title="2. 交换分区（Swap partition）"></a>2. 交换分区（Swap partition）</h3><ul><li>将分区设置为Linux交换区域（<span class="label danger">注：指定分区上的所有数据将丢失</span>）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkswap / dev / sd xy</span><br></pre></td></tr></table></figure><ul><li>启用device进行分页：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon /dev/sdxy</span><br></pre></td></tr></table></figure><ul><li>要在启动时启用此交换分区，添加以下内容到/etc/fstab：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UUID=device_UUID none swap defaults 0 0 </span><br><span class="line"><span class="comment">#device_UUID是swap的UUID</span></span><br></pre></td></tr></table></figure><ul><li>通过systemd激活<br>systemd基于两种不同的机制激活交换分区。两者都是的可执行文件 <span class="label warning">/usr/lib/systemd/system-generators</span>。生成器在启动时运行，并创建用于安装的本机systemd单元。首先 <span class="label warning">systemd-fstab-generator</span>读取fstab，生成单元（包括用于交换的单元）。第二步，<span class="label warning">systemd-gpt-auto-generator</span>检查根磁盘以生成单元。它仅在GPT磁盘上运行，并且可以通过分区类型GUID识别交换分区。</li><li>禁用交换</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swapoff / dev / sd xy</span><br><span class="line">swapoff -a  <span class="comment">#禁用所有交换空间</span></span><br></pre></td></tr></table></figure><h3 id="3-交换文件（Swap-file）"><a href="#3-交换文件（Swap-file）" class="headerlink" title="3. 交换文件（Swap file）"></a>3. 交换文件（Swap file）</h3><p><u><em>作为创建整个分区的替代方案，交换文件提供了动态更改大小的功能，并且更容易完全删除。</em></u></p><ul><li>手动创建</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对于Btrfs这种写时复制（copy-on-write）的文件系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#首先创建一个长度为零的文件</span></span><br><span class="line">truncate -s 0 /swapfile</span><br><span class="line"><span class="comment">#使用chattr对其设置 No_COW 属性</span></span><br><span class="line">chattr +C /swapfile</span><br><span class="line"><span class="comment">#禁用压缩</span></span><br><span class="line">btrfs property <span class="built_in">set</span> /swapfile compression none</span><br></pre></td></tr></table></figure><p><i><span class="label danger">注：自Linux内核版本5.0起，Btrfs开始支持交换文件，但有一定限制:<br> (1) 交换文件不能位于快照子卷上。正确的过程是创建一个新的子卷来放置交换文件。<br> (2) 它不支持跨多个设备的文件系统上的交换文件。</span></i></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用fallocate创建一个交换文件（M = Mebibytes，G = Gibibytes）</span></span><br><span class="line">fallocate -l 512M /swapfile</span><br><span class="line"><span class="comment">#注意： Fallocate可能会导致某些文件系统（例如F2FS）出现问题。作为替代，使用dd更可靠，但更慢</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/swapfile bs=1M count=512 status=progress</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置正确的权限（world-readable swap file是一个巨大的本地漏洞）：</span></span><br><span class="line">chmod 600 /swapfile</span><br><span class="line"></span><br><span class="line"><span class="comment">#格式化</span></span><br><span class="line">mkswap /swapfile</span><br><span class="line"></span><br><span class="line"><span class="comment">#激活</span></span><br><span class="line">swapon /swapfile</span><br><span class="line"></span><br><span class="line"><span class="comment">#编辑fstab配置，添加以下条目</span></span><br><span class="line">vim /etc/fstab</span><br><span class="line">/swapfile none swap defaults 0 0</span><br></pre></td></tr></table></figure><p><i><span class="label danger">注：交换文件必须由其在文件系统上的位置指定，而不是由其UUID或LABEL指定</span></i></p><ul><li>删除交换文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先关闭</span></span><br><span class="line">swapoff /swapfile</span><br><span class="line"><span class="comment">#再删除</span></span><br><span class="line">rm -f /swapfile</span><br><span class="line"><span class="comment">#最后从/etc/fstab中删除相关条目</span></span><br><span class="line">vim /etc/fstab</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>自动创建<br><u><em>systemd-swap是一个脚本，用于从zram交换、交换文件和交换分区创建混合交换空间。它与systemd项目无关。</em></u></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装systemd-swap包</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Nefelim4ag/systemd-swap.git</span><br><span class="line"><span class="built_in">cd</span> systemd-swap</span><br><span class="line">sudo make install</span><br><span class="line"><span class="comment">#设置/etc/systemd/swap.conf的交换文件分块配置</span></span><br><span class="line">swapfc_enabled=1</span><br><span class="line">? swapfc_force_preallocated=1 (如果日志一直报这个错误systemd-swap[..]: WARN: swapFC: ENOSPC，就开启)</span><br><span class="line"><span class="comment">#启动systemd-swap服务</span></span><br><span class="line">sudo service systemd-swap start</span><br></pre></td></tr></table></figure><h3 id="4-性能"><a href="#4-性能" class="headerlink" title="4. 性能"></a>4. 性能</h3><p><u><em>交换操作通常比直接访问RAM中的数据要慢得多。完全禁用交换以提高性能有时会导致性能下降，因为这会减少可用于VFS缓存的内存，从而导致更频繁、更昂贵的磁盘I/O。</em></u></p><h4 id="4-1-两个影响swap性能的参数"><a href="#4-1-两个影响swap性能的参数" class="headerlink" title="4.1. 两个影响swap性能的参数"></a>4.1. 两个影响swap性能的参数</h4><ul><li><strong>Swappiness</strong><br>swappiness sysctl参数表示内核对交换空间的偏好(或避免)。Swappiness的值可以在0到100之间，默认值是60。低值导致内核避免交换，高值导致内核尝试使用交换空间。在足够的内存上使用较低的值可以提高许多系统的响应能力。</li><li><strong>VFS cache pressure</strong><br>它控制内核回收用于缓存VFS caches的内存的趋势，而不是pagecache和swap。增加这个值会增加回收VFS缓存的速度。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#检查当前swappiness|vfs_cache_pressure值（或者可以查看文件/sys/fs/cgroup/memory/memory.swappiness或/proc/sys/vm/swappiness）</span></span><br><span class="line">sysctl vm.swappiness</span><br><span class="line">sysctl vm.vfs_cache_pressure</span><br><span class="line"></span><br><span class="line"><span class="comment">#临时设置（由于/proc组织性很差，仅出于兼容性目的而保留，因此建议使用/sys代替）</span></span><br><span class="line">sysctl -w vm.swappiness=10</span><br><span class="line">sysctl -w vm.vfs_cache_pressure=50</span><br><span class="line"></span><br><span class="line"><span class="comment">#永久设置</span></span><br><span class="line">vim /etc/sysctl.d/99-swappiness.conf</span><br><span class="line">vm.swappiness=10</span><br><span class="line">vm.vfs_cache_pressure=50</span><br></pre></td></tr></table></figure><h4 id="4-2-优先级"><a href="#4-2-优先级" class="headerlink" title="4.2. 优先级"></a>4.2. 优先级</h4><p>如果有多个交换文件或交换分区，则应考虑为每个交换区域分配一个优先级值（0到32767）。在使用优先级较低的交换区之前，系统将使用优先级较高的交换区。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#例，有一个较快的磁盘（/dev/sda）和一个较慢的磁盘（/dev/sdb），为最快的设备上的交换区域分配更高的优先级（pri）</span></span><br><span class="line">/dev/sda1 none swap defaults,pri=100 0 0</span><br><span class="line">/dev/sdb2 none swap defaults,pri=10  0 0</span><br><span class="line"></span><br><span class="line"><span class="comment">#或通过swapon的--priority参数：</span></span><br><span class="line">swapon --priority 100 /dev/sda1</span><br></pre></td></tr></table></figure><h4 id="4-3-使用zswap或zram"><a href="#4-3-使用zswap或zram" class="headerlink" title="4.3. 使用zswap或zram"></a>4.3. 使用zswap或zram</h4><p>Zswap是Linux内核功能，为交换的页面提供压缩的回写缓存。这样可以提高性能并减少IO操作。ZRAM在内存中创建虚拟压缩的交换文件，以替代磁盘上的交换文件。</p><h4 id="4-4-Striping"><a href="#4-4-Striping" class="headerlink" title="4.4. Striping (?)"></a>4.4. Striping (?)</h4><p>出于交换性能的原因，没有必要使用RAID。内核本身可以在多个设备上进行stripe swapping，只要在/etc/fstab文件中赋予它们相同的优先级即可。</p><blockquote><p>链接：<br><a href="https://wiki.archlinux.org/index.php/Swap" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Swap</a><br><a href="https://www.linux.com/news/all-about-linux-swap-space" target="_blank" rel="noopener">https://www.linux.com/news/all-about-linux-swap-space</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;Linux将其物理RAM（随机访问内存）划分为称为页的内存块。Swap是将内存页复制到硬盘上预先配置的空间（称为&lt;span class=&quot;label info&quot;&gt;交换空间&lt;/span&gt;）以释放该内存页的过程。物理内存和交换空间的总大小就是可用的虚拟内存量。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Swap" scheme="http://yoursite.com/tags/Swap/"/>
    
      <category term="文档翻译" scheme="http://yoursite.com/tags/%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
